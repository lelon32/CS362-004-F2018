        -:    0:Source:cardtest4.c
        -:    0:Graph:cardtest4.gcno
        -:    0:Data:cardtest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/************************************************************************* 
        -:    2: * Program: cardtest4 
        -:    3: * Author: Long Le
        -:    4: * Date: 28-Oct-2018 
        -:    5: * Class: CS362
        -:    6: * Instructor: Jaki Shaik
        -:    7: * Assignment 3 
        -:    8: * Description: Unit test program for function Council Room Card.
        -:    9: * Checks how many cards were drawn by each player and where the card was
        -:   10: * drawn from.
        -:   11: * NOTE: testUpdateCoins.c was used as a base template.
        -:   12: *************************************************************************/
        -:   13:
        -:   14:#include "dominion.h"
        -:   15:#include "dominion_helpers.h"
        -:   16:#include <string.h>
        -:   17:#include <stdio.h>
        -:   18:#include "rngs.h"
        -:   19:
        -:   20:int assertion(int a); 
        -:   21:
        -:   22:// set NOISY_TEST to 0 to remove printfs from output
        -:   23:#define NOISY_TEST 1
        -:   24:
function main called 1 returned 100% blocks executed 81%
        1:   25:int main() {
        1:   26:    int testsPassed=1;
        -:   27:    int i;
        1:   28:    int seed = 1000;
        1:   29:    int numPlayer = 2;
        -:   30:    //int maxBonus = 10;
        1:   31:    int p=0, handCount=0;
        1:   32:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   33:               , remodel, smithy, village, baron, great_hall};
        -:   34:    struct gameState G;
        -:   35:    //int maxHandCount = 5;
        1:   36:    int maxDeckCount = 4;
        -:   37:
        -:   38:    int cards[MAX_HAND]; 
        -:   39:    
       1*:   40:    for (i = 0; i < handCount; i++)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:   41:    {
    #####:   42:        cards[i] = adventurer;
        -:   43:    }
        -:   44:
        1:   45:    printf ("TESTING Council Room Card:\n");
call    0 returned 100%
        1:   46:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   47:    initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        1:   48:    G.handCount[p] = handCount;                 // set the number of cards on hand
        1:   49:    memcpy(G.hand[p], cards, sizeof(int) * handCount); // set all the cards to adventurer 
        -:   50:
        -:   51:    // For Test 3
        1:   52:    int victoryCardPileCount = G.supplyCount[estate] + G.supplyCount[duchy] + G.supplyCount[province];
        -:   53:    int kingdom[10];
       11:   54:    for(i=0; i<10; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:   55:        kingdom[i] = k[i];
        -:   56:    }
        -:   57:    
        -:   58:    // Clear all treasure cards.
        -:   59:    int count;
        5:   60:    for(count=0; count<maxDeckCount; count++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:   61:        G.deck[p][count] = adventurer; 
        -:   62:    }
        -:   63:
        1:   64:    G.deckCount[p] = maxDeckCount; // reset
        -:   65:   
        -:   66:/***************************TEST 1*******************************/
        -:   67:      /**Check how many cards were drawn by each player*/
        -:   68:
        -:   69:#if (NOISY_TEST == 1)
        1:   70:        printf("\nTest 1 - verify players' drawn cards");
call    0 returned 100%
        -:   71:#endif
        1:   72:    const int setDeckCount = 5;
        -:   73:    
        -:   74:    // set all player's cards in hand to 0 and decks to 3.
        3:   75:    for(i=0; i<numPlayer; i++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:   76:        G.handCount[i] = 0;
        2:   77:        G.deckCount[i] = setDeckCount;
        -:   78:
        -:   79:        // all cards in decks will be smithy
       12:   80:        for(int j=0; j<5; j++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       10:   81:            G.deck[i][j] = smithy;
        -:   82:        }
        -:   83:    }
        -:   84:    
        1:   85:    int playerBeingTested = 0;
        -:   86:    // test player 0
        1:   87:    G.handCount[0] = 1;
        1:   88:    G.hand[playerBeingTested][0] = council_room;
        -:   89:    //councilRoomCard(&G, playerBeingTested, 0); 
        1:   90:    cardEffect(council_room, 0, 0, 0, &G, 0, 0);
call    0 returned 100%
        -:   91:
        -:   92:    int testResults;
        -:   93:    // test how many cards each player has
        3:   94:    for(i=0; i<numPlayer; i++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   95:#if (NOISY_TEST == 1)
        2:   96:        printf("\nPlayer %d card on hand count is: %d\n", i, G.handCount[i]);
call    0 returned 100%
        -:   97:#endif
        2:   98:        if(i==playerBeingTested) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:   99:            testResults = assertion(G.handCount[playerBeingTested] == 4);
call    0 returned 100%
        -:  100:
        1:  101:            if(!testResults) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  102:                printf("\nERROR: Player %d should have drawn 4 cards!\n", playerBeingTested);
call    0 never executed
    #####:  103:                testsPassed = 0;
        -:  104:            }
        -:  105:        } else {
        1:  106:            testResults = assertion(G.handCount[i] == 1);
call    0 returned 100%
        -:  107:
        1:  108:            if(!testResults) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  109:                printf("\nERROR: Player %d should have drawn 1 card!\n", i);
call    0 never executed
    #####:  110:                testsPassed = 0;
        -:  111:            }
        -:  112:        }
        -:  113:    }
        -:  114:
        -:  115:
        -:  116:/***************************TEST 2*******************************/
        -:  117:      /**Check if card was drawn from current player's deck.*/
        -:  118:#if (NOISY_TEST == 1)
        1:  119:        printf("\nTest 2 - verify if the user's deck was drawn from\n");
call    0 returned 100%
        -:  120:#endif
        1:  121:    testResults = assertion(G.deckCount[playerBeingTested] < setDeckCount );
call    0 returned 100%
        -:  122:
        1:  123:    if(!testResults) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  124:        printf("\nERROR: Player %d's deck was not drawn from!\n", playerBeingTested);
call    0 never executed
    #####:  125:        testsPassed = 0;
        -:  126:    } 
        -:  127:
        1:  128:    if(testsPassed) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  129:        printf("\nALL TESTS SUCCESSFULLY PASSED!\n");
call    0 returned 100%
        -:  130:    } else {
    #####:  131:        printf("\nTEST FAILURES DETECTED\n");
call    0 never executed
        -:  132:    }
        -:  133:}
        -:  134:
        -:  135:/************************************************************************* 
        -:  136: * Description: Custom assertion function to be able to use with coverage
        -:  137: * programs (does not stop program).
        -:  138: * @param a - test conditional statement; false == 0, true >= 1.
        -:  139: *************************************************************************/
function assertion called 3 returned 100% blocks executed 67%
        3:  140:int assertion(int a) {
        3:  141:    if(a<=0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  142:        printf("TEST FAILED! ");    
call    0 never executed
    #####:  143:        return 0;
        -:  144:    }
        -:  145:
        -:  146:#if (NOISY_TEST == 1)
        3:  147:    printf("TEST PASSED\n");    
call    0 returned 100%
        -:  148:#endif
        3:  149:    return 1;
        -:  150:}
